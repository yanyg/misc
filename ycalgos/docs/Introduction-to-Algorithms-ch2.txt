2.1 插入排序

插入排序解决的问题：
    输入：n个数构成的序列<a1, a2, ..., an>
    输出：排序输入序列<a1, a2, ..., an>为<a1', a2', ..., an'>，满足a1' <= a2' <= ... <= an'

view plain

    伪码：  
        INSERTION-SORT(A)  
          for j <- 2 to length[A]  
            do key <- A[j]  
                i <- j - 1  
                while i > 0 and A[i] > key  
                    do A[i+1] <- A[i]  
                        i <- i - 1  
                A[i+1] = key  
      
    C代码：(C的数组下标从0开始，而伪码中从1开始)  
    void insertion_sort(int *arr, size_t size)  
    {  
        int i, j, key;  
      
        assert(NULL != arr);  
      
        for (j = 1; j < size; ++j) {  
            key = arr[j];  
      
            for (i = j - 1; i >= 0 && arr[i] > key; --i)  
                arr[i+1] = arr[i];  
      
            arr[i+1] = key;  
        }  
    }  


正确性分析：
    说明：
        插入算法在执行循环之前，A[1,j-1]是已排好序的，而每次循环都保持这个情况，因此当j从2到length[A]循环完成后，整个数组已排序。
    初始：
        j＝2，A[1,j-1]只包含一个元素A[1]，因此是已排序的；
    保持：
        对于任意j(2 <= j <= length[A])，保存A[j]到key
        内部循环总是从A[j-1], A[j-2], ..., A[1]序列中依次查找所有大于A[j]的值并依次后移。
        当循环结束时，A[i+1,j]中存放所有大于key的值，而A[1,i-1]中存放所有不大于key的值，且A[i]是空闲的。
        存放key到A[i]。
        因此每次循环后，A[1,j]是有序的。
    退出：
        j > length[A]时循环结束，此时A[1,length[A]]全部有序。

数学归纳法证明：
    当j=2时，A[1,j-1]只包含一个元素A[1]，因此肯定是有序的。
    假定对于任意j=m(2 <= m < length[A])，循环完成后有A[1,j]有序
    则当j=m+1时：
        A[1,m]肯定有序。
        保存A[m+1]到key。
        内层循环结束时，A[1,i]子数组中所有元素不大于key，而A[i+2,m+1]子数组中所有元素大于key，A[i+1]不持有有效数据。
        保存key到A[i+1]。
        综上可知：A[1,m+1]此时是有序的。

    因此对于所有的j(2 <= j <= length[A])，在任意时刻，有A[1,j]有序。
    当循环迭代到j=length[A]算法结束时，数组A已排序。

测试程序：
    可以通过如下程序测试插入排序算法的正确性。其中辅助函数print_arr、init_arr可能在以后多次用到：
view plain

    #include <assert.h>  
    #include <stdio.h>  
    #include <stdlib.h>  
    #include <time.h>  
      
    void insertion_sort(int *arr, size_t size)  
    {  
        int key;  
        int i, j;  
      
        assert(NULL != arr);  
      
        for (j = 1; j < size; ++j) {  
            key = arr[j];  
            for (i = j - 1; i >= 0 && arr[i] > key; --i)  
                arr[i+1] = arr[i];  
            arr[i+1] = key;  
        }  
    }  
      
    void print_arr(const int *arr, size_t size, const char *info)  
    {  
        int i;  
      
        assert(NULL != arr);  
      
        printf("%s: ", info);  
        for (i = 0; i < size; ++i)  
            printf("%d ", arr[i]);  
        printf("\n");  
    }  
      
    void init_arr(int *arr, size_t size)  
    {  
        int i;  
      
        assert(NULL != arr);  
      
        srand((unsigned int)time(NULL));  
      
        for (i = 0; i < size; ++i)  
            arr[i] = rand()%100;  
    }  
      
    int main()  
    {  
        int arr[10];  
      
        init_arr(arr, 10);  
        print_arr(arr, 10, "before");  
        insertion_sort(arr, 10);  
        print_arr(arr, 10, "after");  
      
        return 0;  
    }  


习题：
2.1-1 以图2-2为模型，说明INSERTION-SORT在数组A=<31,41,59,26,41,58>上的执行过程。
如下：
view plain

    31,    41(j), 59,    26,    41,    58  
    31(j), 41,    59(j), 26,    41,    58  
    26,    31,    41,    59(j), 41,    58  
    26,    31,    41,    41,    59(j), 58  
    26,    31,    41,    41,    58,    59(j)  

标注为x(j)的元素表示此时正在以j执行循环。

2.1-2 重写过程INSERTION-SORT，使之按非升序（而不是按非降序）排序。
只需要更改一行：
更改
    while i > 0 and A[i] > key
为
    while i > 0 and A[i] < key
即可。

2.1-3 考虑下面的查找问题：
    输入：一列数A=<a1,a2,…,an>和一个值V。
    输出：下标i，使得V=A[i]，或者当V不再A中出现时为NIL。
写出针对这个问题的线性查找的伪代码，它顺序地扫描整个序列以查找V。利用循环不变式证明算法的正确性。确保所给出的循环不变式满足三个必要的性质。
FIND-LINEAR(A, v, i)
    i <- NIL
    j <- 1
    while j <= length[A] and A[j] != v
        do j <- j + 1
    if j <= length[A]
        then i <- NIL
view plain

    int find_linear(const int *arr, size_t size, int v)  
    {  
        int i;  
      
        for (i = 0; i < size && arr[i] != v; ++i);  
      
        if (i == size) i = -1;    /* -1 means NIL */  
      
        return (int)i;  
    }  


证明：
    初始：
        i＝NIL，初始化为未查找到。

    保持：
        从j=1到length[A]，依次判断，如果A[j]等于v，则结束循环。

    退出：
        循环结束时，判断j是否有效
        如果j在有效范围（小于等于length[A])，则证明查找成功，因此设置i为正确的索引。
        否则，循环因为越界结束，v没有找到，i依然为NIL。

2.1-4 有两个各存放在数组A和B中的n位二进制整数，考虑它们的相加问题。两个整数的和以二进制形式存放在具有(n+1)个元素的数组C中。请给出这个问题的形式化描述，并写出伪代码。

存储说明：最高位存在数组的第一个元素中，最低位存在数组的最后一个元素中。
    因为A/B各有n个元素而C有n+1个元素，因此对于任意i(1 <= i <= n)，A[i]、B[i]和C[i+1]总在相同位（权数）。如下：
view plain

    位 (n+1)   (n)  (n-1)  ...   (2)     (1)  
    A         A[0]  A[1]   ...  A[n-1]  A[n]  
    B         B[0]  B[1]   ...  B[n-1]  B[n]  
    C  C[0]   C[1]  C[2]   ...  C[n]    C[n+1]  

view plain

    伪码：  
    BINARY-SUM(A, B, C, n)  
        for i <- 1 to n+1  
            do C[i] <- 0  
      
        for i <- n to 1  
            do if A[i] + B[i] + C[i+1] >= 2  
                    then C[i] <- 1  
                C[i+1] <- (C[i+1] + A[i] + B[i])%2  
      
    C代码：  
    void binary_sum(const int *arr_a, const int *arr_b, int *arr_c, size_t n)  
    {  
        int i;  
      
        assert(NULL != arr_a && NULL != arr_b && NULL != arr_c);  
      
        for (i = 0; i < n+1; ++i)  
            arr_c[i] = 0;  
      
        if (0 == n) return;  
      
        for (i = n-1; i >= 0; --i) {  
            if (arr_a[i] + arr_b[i] + arr_c[i+1] >= 2)  
                arr_c[i] = 1;  
      
            arr_c[i+1] = (arr_a[i] + arr_b[i] + arr_c[i+1])%2;  
        }  
    }  


形式化描述：
    初始C数组为0。从n到1反向遍历（因为数组第一个元素存储最高为、最后一个元素存储最低位），每次都考虑加法是否需要进位，并设置该位的结果。当循环结束时，C中保存有正确的加法结果。
    如果最终的结果依然为n位（最高为没有进位），则C[1]依然为0，对结果没有影响。

证明：
    初始：
        C中各元素为0，加法尚未开始，因此肯定正确。
    保持：
        对于每一位，当A[i]+b[i]+C[i+1]>=2时，表示需要进位，而此时C[i]肯定为0，因此直接设置为1即可。
        对于C[i+1]，如果上次运算有进位，则C[i+1]初始值为1，因此需要考虑A[i]+b[i]+C[i+1]三个位置的值，运算结果为(C[i+1] + A[i] + B[i])%2
    退出：
        循环结束时，A和B中的所有位已经处理过了，如果最高为有进位，则存储在C[1]中，否则C[1]保持为0，因此结果是正确的。 

2.2 算法分析
算法分析：
	预测算法运行所需资源。
	资源通常是指算法运行时间。
	实际中需要考虑的其他资源包括：内存、通信带宽、硬件等。

实现模型：
	通用处理器；
	随机存取RAM；
	均等的指令成本，例如当k较小时（小于等于处理器位宽），2^k可认为在常数时间内完成（移位操作）。

插入排序分析：
	T(n) = Θ(n^2)

最坏/好、平均/期望算法运行时间：
	最坏/好：算法上/下界（阈值）
	平均/期望：随机化分析结果

增长指数：
	只统计增长最快项，因为当n增大时，增长最快项是关键。
	实际项目中，还需要考虑输入规模和实现的复杂度、可维护性等。
	衡量方法Θ

习题：
2.2-1 用Θ形式表示函数n^3/1000-100n^2-100n+3。
Θ(n^3)

2.2-2 考虑对数组A中的n个数进行排序的问题：首先找出A中的最小元素，并将其与A[1]中元素进行交换。接着，找出A中的次最小元素，并将其与A[2]中的元素进行交换。对A中头n-1个元素继续这一过程。写出这个算法的伪代码，该算法称为选择排序(selection)。对这个算法来说，循环不变式是什么？为什么它仅需要在头n-1个元素上运行，而不是在所有n个元素上运行？以Θ形式写出选择排序的最佳和最坏情况下的运行时间。
伪码：
SELECTION-SORT(A)
	for i <- 1 to length[A]-1
		do min <- i
			for j <- i+1 to length[A]
				do if A[j] < A[min]
					then min <-j
			exchange(A[i], A[min])
C代码：
void selection_sort(int *arr, size_t size)
{
	int i, j, min;

	assert(NULL != arr);

	for (i = 0; i < size; ++i) {
		min = i;
		for (j = i + 1; j < size; ++j) {
			if (arr[j] < arr[min])
				min = j;
		}
		/* exchanges */
		if (min != i) {
			arr[i] = arr[i]^arr[min];
			arr[min] = arr[min]^arr[i];
			arr[i] = arr[i]^arr[min];
		}
	}
}

循环不变式：
	初始：
		i=1，A[1,i]只包含一个元素即A[1]，因此A[1,i]有序。
	保持：
		每次i迭加时，总是查找A[i, length[A]]中的最小元素，然后和A[i]交换，因此循环后，A[i]大于等于A[1,i-1]中的任何元素，且小于A[i+1,length[A]]中的任何元素。
		因此迭代完成后，A[1,i]依然是有序的。
	退出：
		当i=length[A]-1时退出。此时A[1,i]所有元素均小于A[length[A]]且有序，因此数组A已排序。

对于选择排序，当前n-1个元素已排序时，剩下的一个元素一定是最大的一个，因此不再需要循环判断。

最佳和最坏运行时间相等，都是Θ(n^2)

2.2-3 再次考察线性查找问题（见练习2.1-3）。在平均情况下，需要检查输入序列中的多少个元素？假定待查找的元素是数组中任何一个元素的可能性是相等的。在最坏情况下又是怎么样？用Θ形式表示的话，线性查找的平均情况和最坏情况运行时间怎样？对你的答案加以说明。

平均需要查找n/2个元素；
最坏需要查找n个元素；
Θ形式的平均和最坏相同，都是Θ(n)。

2.2-4 应如何修该任何一个算法，才能使之具有较好的最佳运行时间？
针对最大概率的输入定制优化一个算法，可获得最佳运行时间。
比如在输入规模很小时，首要考虑算法的常数系数。输入规模很大时，则优先考虑最高项（即Θ结果)。
