第3章 函数的增长

3.1 渐近记号
表示算法的渐近运行时间的记号是用定义域为自然数集N = {0, 1, 2, ...}的函数来定义的。这些记号用来表示最坏情况运行时间T(n)。

Θ记号
	Θ(g(n)) = {f(n): 存在正常数c1,c2和n0，使对所有的n≥n0，有0 ≤ c1*g(n) ≤ f(n) ≤ c2*g(n)}
O记号
	O(g(n)) = {f(n): 存在正常数c和n0，使对所有的n≥n0，有0 ≤ f(n) ≤ c*g(n)}
Ω记号
	Ω(g(n)) = {f(n): 存在正常数c和n0，使对所有的n≥n0，有0 ≤ c*g(n) ≤ f(n)}

Θ称为渐近确界，O称为渐近上界，Ω称为渐近下界。

定理3.1 对任意两个函数f(n)和g(n)，f(n) = Θ(g(n)) 当且仅当f(n) = O(g(n))和f(n) = Θ(g(n))。

o记号：
	o(g(n)) = {f(n): 对任意正常数c，存在常数n0 > 0，使对所有的n≥n0，有0 ≤ f(n) ≤ c*g(n)}
ω记号：
	ω(g(n)) = {f(n): 对任意正常数c，存在常数n0 > 0，使对所有的n≥n0，有0 ≤ c*g(n) ≤ f(n)}

传递性:
	f(n) = Θ(g(n)) && g(n) = Θ(h(n)) ==> f(n) = Θ(h(n))
	f(n) = O(g(n)) && g(n) = O(h(n)) ==> f(n) = O(h(n))
	f(n) = Ω(g(n)) && g(n) = Ω(h(n)) ==> f(n) = Ω(h(n))
	f(n) = o(g(n)) && g(n) = o(h(n)) ==> f(n) = o(h(n))
	f(n) = ω(g(n)) && g(n) = ω(h(n)) ==> f(n) = ω(h(n))
自反性:
	f(n) = Θ(f(n))
	f(n) = O(f(n))
	f(n) = ω(f(n))
对称性:
	f(n) = Θ(g(n)) 当且仅当g(n) = Θ(f(n))
转置对称性:
	f(n) = O(g(n)) 当且仅当g(n) = Ω(f(n))
	f(n) = Ω(g(n)) 当且仅当g(n) = O(f(n))

练习:
3.1-1 设f(n)与g(n)都是渐近非负函数。利用Θ记号的基本定义来证明max(f(n), g(n)) = Θ(f(n) + g(n))。
证明：
	题目等价于求证，存在常数c1, c2和自然数n0，使得：
		0 ≤ c1 * (f(n) + g(n)) ≤ max(f(n) + g(n)) ≤ c2 * (f(n) + g(n))
	对于所有的n≥n0成立。
	选择c1=1/2, c2=2可知不等式对所有n≥0均成立。
	证毕。

3.1-2 证明对任意实常数a和b，其中b>0，有：
	(n+a)^b = Θ(n^b)
证明：
	根据二项式定理，有:
	(n+a)^b = C(b,0) * (n^b) + C(b,1) * (n^(b-1)) * a + C(b,b-1) * n * (a^(b-1)) * C(b,b) * (a^b)
	其中C(b,x)表示b中选取x个的组合，n^b表示n的b次方。
	由于b>0，因此Θ由n的最高次项决定，可得：
	(n+a)^b = Θ(n^b)

3.1-3 解释为什么“算法A的运行时间至少是O(n^2)”是没意义的。
O记号表明算法运行时间渐近上界。因此描述“算法A的运行时间至多为O(n^2)”。因此题目所说没有意义。

3.1-4 2^(n+1) = O(2^n)成立吗，2^(2n) = O(2^n)成立吗？
2^(n+1) = O(2^n) 成立。因为2^(n+1) = 2 * (2^n)，因此当c=2时，对任意n≥0，有2^(n+1) ≤ 2 * (2^n)成立。
2^(2n) = O(2^n)不成立。因为2^(2n) = (2^n)^2，不存在常数c和n0可以满足(2^n)^2 < c * (2^n)。

3.1-5 证明定理3.1
证明：
	充分条件：
		当f(n) = Θ(g(n))时，存在常数c1, c2和n0，使得：
			0 ≤ c1 * g(n) ≤ f(n) ≤ c2 * g(n)
		由0 ≤ c1 * g(n) ≤ f(n)可知f(n) = O(g(n))。
		由0≤ f(n) ≤ c2 * g(n)可知f(n) = Ω(g(n))。
	同理可得f(n) = O(g(n))和f(n) = Ω(g(n))是f(n) = Θ(g(n))的必要条件。

3.1-6 证明：一个算法运行时间是Θ(g(n))当且仅当其最坏运行情况是O(g(n))，且最佳运行情况是Ω(g(n))。
证明：
	记算法运行时间为f(n)，则：
	最坏运行情况是O(g(n))，可知存在常数c2和n0'，当n≥n0'时有：0 ≤ f(n) ≤ c2 * g(n)
	最佳运行情况是Ω(g(n))，可知存在常数c1和n0''，当n≥n0''时有：0 ≤ c1 * g(n) ≤ f(n)
	取n0为n0'和n0''较大者，则上述两式同时满足，因此，对于n0≥max(n0',n0'')，有：
		0 ≤ c1 * g(n) ≤ f(n) ≤ c2 * g(n)，
	因此有f(n) = Θ(g(n))。

3.1-7 证明o(g(n)) ∩ ω(g(n))是空集。
证明:
	假定o(g(n)) ∩ ω(g(n))非空，则：
		o(g(n)) ==> 对所有常数c1，存在n0 > 0，满足0 ≤ f(n) ≤ c1 * g(n)
		ω(g(n)) ==> 对所有常数c2，存在n0 > 0，满足0 ≤ c2 * g(n) ≤ f(n)
		两者的交集：对所有常数c1和c2，存在0 ≤ c2 * g(n) ≤ f(n) ≤ c1 * g(n)
		令c2 > c1，可知对于任意n，上式均不成立。
	因此o(g(n)) ∩ ω(g(n))为空集。

3.1-8 可以将我们的表示法扩展到有两个参数n和m的情形，其中n和m的值可以以不同的速率，互相独立地趋于无穷。
对给定的函数g(n, m)，O(g(n, m))为函数集O(g(n, m))={f(n, m): 存在正整数c, n0和m0，使对所有n ≥ n0或m ≥ m0，有0 ≤ f(n, m) ≤ c *g(n, m)}。
给出对应的Ω(g(n, m))和Θ(g(n, m))的定义。
Ω(g(n, m)) = {f(n, m): 存在正整数c, n0和m0, 使对所有n ≥ n0 或 m ≥ m0，有0 ≤ cg(n, m) ≤ f(n, m) }
Θ(g(n, m)) = {f(n, m): 存在正整数c1, c2, n0和m0, 使对所有n ≥ n0 或 m ≥ m0，有0 ≤ c1 * g(n, m) ≤ f(n, m) ≤ c2 * g(n, m)}

3.2 标准记号和常用函数
单调性:
	若m ≤ n 时，有f(m) ≤ f(n)，则函数f(n)是单调递增的。
	若m ≤ n 时，有f(m) ≥ f(n)，则函数f(n)是单调递减的。
下取整(floor)和上取整(ceiling):
	x-1 < ⌊x⌋ ≤ x ≤ ⌈x⌉ ≤ x + 1
取模运算:
	a mod n = a - ⌊a/n⌋*n
多项式:
	f(n) = O(Σ(a[i] * (n^i))) (i从0到k)
指数式:
	f(n) = O(n^k)
对数式:
	f(n) = O(lgn)
阶乘:
	nlgn ≤ n! ≤ n^n, lg(n!) = Θ(nlgn)
函数迭代:
	f[i](n) = n, 如果i = 0
	f[i](n) = f(f[i-1](n)), 如果i > 0
多重对数函数:
	lg*n = min { i > 0: lg[i]n ≤ 1 }
斐波那契数(Fibonacci):
	F[0] = 0
	F[1] = 1
	F[i] = F[i-1] + F[i-2] 当i ≥ 2时

	F[i] = ( (1+(5^(1/2)))^i - (1-(5^(1/2)))^i ) / (5^(1/2))

练习:
3.2-1 证明: 若f(n)和g(n)是单调递增函数，则f(n)+g(n)和f(g(n))也是单调递增的；
另外，若f(n)和g(n)是非负的，那么f(n)*g(n)是单调递增的。
证明：
	令m ≤ n, 则有 f(m) ≤ f(n), g(m) ≤ g(n)，可知:
	f(m) + g(m) ≤ f(n) + g(n)
	因此f(n)+g(n)是单调递增的。

	令m ≤ n, 有 g(m) ≤ g(n),
	令s=g(m), t=g(n), 则 s ≤ t, 因此有: f(s) ≤ f(t)
	用g(m)和g(n)替换s和t，可得:
	f(g(m)) ≤ f(g(n))
	因此f(g(n))是单调递增的。

	令m ≤ n，有0 ≤ f(m) ≤ f(n) 且 0 ≤ g(m) ≤ g(n)，
	可知: 0 ≤ f(m)*g(m) ≤ f(n)*g(n)
	因此f(n)*g(n)是单调递增的。

3.2-2 证明等式3.15
3.15等式如右: logb(1/a) = -logba, logba = 1/logab, a^(logbc) = c^(logba)
证明:
	logb(1/a) = logb(a^-1) = -logba
	令c=logba, 则a=b^c, 两端取loga对数有
		logaa = loga(b^c) = c * logab
		==> 1 = logba * logab
		==> logba = 1/logab
	令x=logbc, y=logac, 则 b^x = c = a^y
	logbc = logb(a^y) = y*logba = logac * logba
	两边取a的指数,可得:
	a ^ (logbc) = a ^ (logac * logba)
	而 a ^ (logac * logba) = (a^logac) ^ logba = c^logba

3.2-3 证明等式3.18。并证明n!=ω(2^n)和n!=o(n^n)。
    ( 3.18: n! = o(n^n), n! = ω(2^n), lg(n!) = Θ(nlgn) )
证明:

*3.2-4 函数⌈lgn⌉!是否多项式有界？函数⌈lg lgn⌉!呢？
*3.2-5 哪一个在渐近上更大些: lg(lg*n)还是lg*(lgn)？
3.2-6 用归纳法证明: 第i个斐波那契数满足等式
	Fi = ( (1+(5^(1/2)))^i - (1-(5^(1/2)))^i ) / (5^(1/2))
其中(1+(5^(1/2)))是黄金分割律，(1-(5^(1/2)))是共轭数。
3.2-7 证明: 对于i ≥ 0, 第(i+2)个斐波那契数满足F[i+2] ≥ (1+(5^(1/2)))^i。

思考题
3-1 多项式的渐近性质

